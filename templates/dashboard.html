<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>硬件监控面板</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        :root {
            --bg: #0f1c2e;
            --card: #14283b;
            --card-border: rgba(255, 255, 255, 0.08);
            --text: #e6eef7;
            --muted: #9bb0c3;
            --accent: #4cc9f0;
            --accent-2: #20c997;
            --warning: #ffb74d;
            --danger: #ff6b6b;
            --shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: "Segoe UI", "Inter", Arial, sans-serif;
        }

        .page {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .page-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-icon {
            font-size: 1.8rem;
            color: var(--accent);
        }

        .page-header h1 {
            margin: 0;
            font-size: 1.4rem;
        }

        .subtitle {
            color: var(--muted);
            font-size: 0.9rem;
            margin-top: 2px;
        }

        .header-right {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--muted);
        }

        .meta-item i {
            color: var(--accent);
        }

        .grid {
            column-count: 1;
            column-gap: 16px;
            margin-top: 16px;
        }

        @media (min-width: 900px) {
            .grid {
                column-count: 2;
            }
        }

        .card {
            background: var(--card);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 16px;
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            break-inside: avoid;
            page-break-inside: avoid;
            margin-bottom: 16px;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .card-title {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .card-title i {
            color: var(--accent);
        }

        .title-meta {
            font-size: 0.8rem;
            color: var(--muted);
            font-weight: 500;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .card-subtitle {
            color: var(--muted);
            font-size: 0.85rem;
            text-align: right;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
        }

        .stats-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .stat {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 8px 10px;
        }

        .stat .label {
            font-size: 0.75rem;
            color: var(--muted);
        }

        .stat .value {
            font-size: 1rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .progress {
            height: 8px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 999px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            width: 0%;
            transition: width 0.3s ease;
        }

        .chart {
            height: 170px;
        }

        .chart-sm {
            height: 140px;
        }

        .chart canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .core-grid {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            gap: 8px;
            max-height: 240px;
            overflow: auto;
            padding-right: 4px;
        }

        .core-item {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 4px;
            text-align: center;
            line-height: 1.1;
        }

        .core-label {
            font-size: 0.62rem;
            color: var(--muted);
        }

        .core-usage {
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 2px;
        }

        .core-temp {
            font-size: 0.65rem;
            margin-top: 2px;
            color: var(--accent-2);
        }

        .core-high .core-usage {
            color: var(--danger);
        }

        .core-medium .core-usage {
            color: var(--warning);
        }

        .core-low .core-usage {
            color: var(--accent);
        }

        .list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .list-item .name {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .list-item .meta {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .disk-usage {
            min-width: 140px;
            text-align: right;
        }

        .kv {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--muted);
        }

        .kv strong {
            color: var(--text);
            font-weight: 600;
        }

        .gpu-metrics {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 10px;
        }

        .gpu-select {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .gpu-option {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.06);
            font-size: 0.85rem;
            color: var(--muted);
        }

        .gpu-option input {
            accent-color: var(--accent);
        }

        .muted {
            color: var(--muted);
        }
    </style>
</head>
<body>
<div class="page">
    <header class="page-header">
        <div class="header-left">
            <i class="fas fa-chart-line header-icon"></i>
            <div>
                <h1>硬件监控面板</h1>
                <div class="subtitle">实时硬件状态与趋势</div>
            </div>
        </div>
        <div class="header-right">
            <div class="meta-item"><i class="fas fa-desktop"></i><span>{{ system.os }}</span></div>
            <div class="meta-item"><i class="fas fa-server"></i><span>{{ system.hostname }}</span></div>
            <div class="meta-item"><i class="fas fa-clock"></i><span id="current-time"></span></div>
            <div class="meta-item"><i class="fas fa-hourglass-half"></i><span>{{ system.uptime }}</span></div>
            <div class="meta-item"><i class="fas fa-arrow-down"></i><span id="network-down">0 KB/s</span></div>
            <div class="meta-item"><i class="fas fa-arrow-up"></i><span id="network-up">0 KB/s</span></div>
        </div>
    </header>

    <section class="grid">
        {% set total_temp = 0 %}
        {% set count = 0 %}
        {% for temp in cpu_temps %}
        {% set total_temp = total_temp + temp.value %}
        {% set count = count + 1 %}
        {% endfor %}
        {% set avg_temp = (total_temp / count) if count > 0 else 0 %}

        <div class="card cpu-card">
            <div class="card-header">
                <h2 class="card-title"><i class="fas fa-microchip"></i> CPU</h2>
                <div class="card-subtitle">{{ cpu_name }}</div>
            </div>
            <div class="chart">
                <canvas id="cpu-chart"></canvas>
            </div>
            <div class="core-grid" id="core-grid">
                {% for i in range(cpu_usage_per_core|length) %}
                <div class="core-item" data-core-index="{{ i }}">
                    <div class="core-label">Core {{ i }}</div>
                    <div class="core-usage">{{ cpu_usage_per_core[i]|round(1) }}%</div>
                    <div class="core-temp">
                        {% if i < cpu_temps|length %}
                            {{ cpu_temps[i].value }}°C
                        {% else %}
                            N/A
                        {% endif %}
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>

        <div class="card memory-card">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-memory"></i> 内存
                    <span class="title-meta">
                        <span id="memory-type">{{ memory.type if memory and memory.type else 'Unknown' }}</span>
                        <span id="memory-frequency">{{ memory.frequency if memory and memory.frequency else 'Unknown' }} MHz</span>
                        <span id="memory-total">
                            {% if memory and memory.total is defined %}
                                {{ "%.1f"|format(memory.total/1073741824) }} GB
                            {% else %}
                                N/A
                            {% endif %}
                        </span>
                        <span id="memory-channels">{{ memory.channels if memory and memory.channels else 'Unknown' }}</span>
                    </span>
                </h2>
                <div class="card-subtitle">实时使用情况</div>
            </div>
            <div class="progress">
                <div class="progress-bar" id="memory-progress" style="width: {{ memory.percent if memory and memory.percent is defined else 0 }}%"></div>
            </div>
            <div class="chart chart-sm">
                <canvas id="memory-chart"></canvas>
            </div>
        </div>

        <div class="card gpu-card">
            <div class="card-header">
                <h2 class="card-title"><i class="fas fa-layer-group"></i> GPU</h2>
                <div class="card-subtitle">多卡趋势</div>
            </div>
            {% if gpu_info and gpu_info|length > 0 %}
            <div class="gpu-select" id="gpu-select">
                {% for gpu in gpu_info %}
                <label class="gpu-option">
                    <input class="gpu-toggle" type="radio" name="gpu-select" data-gpu-index="{{ loop.index0 }}" {% if loop.first %}checked{% endif %}>
                    <span>GPU{{ loop.index0 }} {{ gpu.name if gpu.name is defined else '未知GPU' }}</span>
                </label>
                {% endfor %}
            </div>
            <div class="chart chart-sm">
                <canvas id="gpu-chart"></canvas>
            </div>
            {% else %}
            <div class="muted">未检测到GPU</div>
            {% endif %}
        </div>

        {% set skip_fstypes = ['squashfs', 'tmpfs', 'devtmpfs', 'overlay', 'proc', 'sysfs', 'cgroup', 'pstore', 'autofs', 'debugfs', 'tracefs', 'securityfs', 'mqueue'] %}
        {% set filtered_disks = [] %}
        {% for disk in disks %}
        {% set fs_type = disk.filesystem if disk.filesystem is defined else (disk.fstype if disk.fstype is defined else '') %}
        {% if disk.total is defined
              and fs_type not in skip_fstypes
              and ((disk.total is number and disk.total/1024/1024/1024 > 50) or (disk.total is not number and disk.total|float/1024/1024/1024 > 50)) %}
        {% set _ = filtered_disks.append(disk) %}
        {% endif %}
        {% endfor %}
        {% set disk_ns = namespace(total=0, used=0) %}
        {% for disk in filtered_disks %}
        {% if disk.total is defined and disk.used is defined %}
        {% set disk_ns.total = disk_ns.total + (disk.total if disk.total is number else disk.total|float) %}
        {% set disk_ns.used = disk_ns.used + (disk.used if disk.used is number else disk.used|float) %}
        {% endif %}
        {% endfor %}
        {% set disk_percent = (disk_ns.used / disk_ns.total * 100) if disk_ns.total > 0 else 0 %}

        <div class="card storage-card">
            <div class="card-header">
                <h2 class="card-title"><i class="fas fa-hdd"></i> 存储</h2>
                <div class="card-subtitle">总使用率 <span id="disk-percent">{{ disk_percent|round(1) }}%</span></div>
            </div>
            <div class="list">
                {% if filtered_disks|length > 0 %}
                {% for disk in filtered_disks|sort(attribute='total', reverse=true) %}
                <div class="list-item">
                    <div>
                        <div class="name">
                            {% if disk.mountpoint is defined and disk.mountpoint %}
                                {{ disk.mountpoint }}
                            {% elif disk.device is defined %}
                                {{ disk.device }}
                            {% else %}
                                未知挂载
                            {% endif %}
                        </div>
                        <div class="meta">
                            {% if disk.device is defined %}{{ disk.device }}{% endif %}
                            {% if disk.filesystem is defined %} ({{ disk.filesystem }}){% endif %}
                        </div>
                    </div>
                    <div class="disk-usage">
                        <div class="meta">
                            {% if disk.used is defined and disk.total is defined %}
                            {{ "%.1f"|format(disk.used|float/1024/1024/1024) }} / {{ "%.1f"|format(disk.total|float/1024/1024/1024) }} GB
                            {% endif %}
                        </div>
                        <div class="progress">
                            <div class="progress-bar" style="width: {{ disk.percent if disk.percent is defined else 0 }}%"></div>
                        </div>
                    </div>
                </div>
                {% endfor %}
                {% else %}
                <div class="muted">暂无可用磁盘数据</div>
                {% endif %}
            </div>
        </div>

        <div class="card network-card">
            <div class="card-header">
                <h2 class="card-title"><i class="fas fa-network-wired"></i> 网络</h2>
                <div class="card-subtitle">实时上传/下载</div>
            </div>
            <div class="chart chart-sm">
                <canvas id="network-chart"></canvas>
            </div>
        </div>
    </section>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script>
    const HISTORY_LIMIT = 60;
    const charts = {
        cpu: null,
        memory: null,
        disk: null,
        network: null,
        gpu: null
    };

    let lastNet = null;
    let lastNetTime = Date.now();

    function updateTime() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('zh-CN', { hour12: false });
        const dateString = now.toLocaleDateString('zh-CN');
        const timeElement = document.getElementById('current-time');
        if (timeElement) {
            timeElement.textContent = `${dateString} ${timeString}`;
        }
    }

    function createLineChart(canvasId, datasets, extraOptions = {}) {
        const ctx = document.getElementById(canvasId);
        if (!ctx) return null;
        return new Chart(ctx.getContext('2d'), {
            type: 'line',
            data: {
                labels: [],
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    mode: 'nearest',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: '#9bb0c3'
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#9bb0c3' },
                        grid: { display: false }
                    },
                    y: {
                        ticks: { color: '#9bb0c3' },
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    }
                },
                ...extraOptions
            }
        });
    }

    function pushChartPoint(chart, label, values, metaValues = []) {
        if (!chart) return;
        if (chart.data.labels.length >= HISTORY_LIMIT) {
            chart.data.labels.shift();
            chart.data.datasets.forEach(dataset => {
                dataset.data.shift();
                if (Array.isArray(dataset.coreIndex)) {
                    dataset.coreIndex.shift();
                }
            });
        }
        chart.data.labels.push(label);
        values.forEach((value, index) => {
            if (chart.data.datasets[index]) {
                chart.data.datasets[index].data.push(value);
                if (Array.isArray(chart.data.datasets[index].coreIndex)) {
                    const metaValue = metaValues[index] ?? null;
                    chart.data.datasets[index].coreIndex.push(metaValue);
                }
            }
        });
        chart.update('none');
    }

    function formatSpeed(bytesPerSecond) {
        if (bytesPerSecond < 1024) {
            return `${bytesPerSecond.toFixed(1)} B/s`;
        }
        if (bytesPerSecond < 1024 * 1024) {
            return `${(bytesPerSecond / 1024).toFixed(1)} KB/s`;
        }
        return `${(bytesPerSecond / 1024 / 1024).toFixed(1)} MB/s`;
    }

    function calcAvgCoreTemp(temps) {
        const entries = Object.entries(temps || {}).filter(([name]) => name.toLowerCase().includes('core'));
        let sum = 0;
        let count = 0;
        entries.forEach(([_, value]) => {
            const tempValue = typeof value === 'object' && value !== null ? value.value : value;
            if (typeof tempValue === 'number') {
                sum += tempValue;
                count += 1;
            }
        });
        return count > 0 ? sum / count : null;
    }

    function getSortedCoreTemps(temps) {
        const entries = Object.entries(temps || {})
            .filter(([name]) => name.toLowerCase().includes('core'))
            .map(([name, value]) => {
                const match = name.match(/(\d+)/);
                return {
                    index: match ? parseInt(match[1], 10) : 0,
                    value: typeof value === 'object' && value !== null ? value.value : value
                };
            })
            .sort((a, b) => a.index - b.index);
        return entries.map(entry => entry.value);
    }

    function getGpuPalette(index) {
        const base = (index * 60) % 360;
        return {
            load: `hsl(${base}, 80%, 60%)`,
            mem: `hsl(${(base + 25) % 360}, 80%, 60%)`,
            temp: `hsl(${(base + 50) % 360}, 80%, 65%)`,
            loadBg: `hsla(${base}, 80%, 60%, 0.12)`,
            memBg: `hsla(${(base + 25) % 360}, 80%, 60%, 0.12)`,
            tempBg: `hsla(${(base + 50) % 360}, 80%, 65%, 0.12)`
        };
    }

    function initCharts() {
        charts.cpu = createLineChart('cpu-chart', [
            {
                label: 'CPU使用率',
                data: [],
                borderColor: '#4cc9f0',
                backgroundColor: 'rgba(76, 201, 240, 0.15)',
                tension: 0.3,
                fill: true
            },
            {
                label: '平均温度',
                data: [],
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139, 92, 246, 0.12)',
                tension: 0.3,
                fill: false,
                yAxisID: 'y1'
            },
            {
                label: '最高核心使用率',
                data: [],
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.12)',
                tension: 0.3,
                fill: false,
                coreIndex: []
            },
            {
                label: '最低核心使用率',
                data: [],
                borderColor: '#7fd3a8',
                backgroundColor: 'rgba(127, 211, 168, 0.12)',
                tension: 0.3,
                fill: false,
                coreIndex: []
            }
        ], {
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    align: 'center',
                    labels: {
                        color: '#9bb0c3',
                        boxWidth: 10,
                        boxHeight: 10,
                        padding: 6,
                        font: {
                            size: 10
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const dataset = context.dataset || {};
                            const value = typeof context.parsed.y === 'number' ? context.parsed.y.toFixed(1) : context.formattedValue;
                            let label = `${dataset.label}: ${value}`;
                            if (Array.isArray(dataset.coreIndex)) {
                                const coreIndex = dataset.coreIndex[context.dataIndex];
                                if (coreIndex !== null && coreIndex !== undefined) {
                                    label += ` (Core ${coreIndex})`;
                                }
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                y: {
                    min: 0,
                    max: 100,
                    title: {
                        display: true,
                        text: '使用率(%)',
                        color: '#4cc9f0',
                        font: { size: 10, weight: '600' }
                    },
                    ticks: {
                        color: '#9bb0c3',
                        callback: (value) => `${value}%`
                    }
                },
                y1: {
                    position: 'right',
                    min: 0,
                    max: 100,
                    grid: { drawOnChartArea: false },
                    title: {
                        display: true,
                        text: '温度(°C)',
                        color: '#ffb74d',
                        font: { size: 10, weight: '600' }
                    },
                    ticks: {
                        color: '#9bb0c3',
                        callback: (value) => `${value}°C`
                    }
                }
            }
        });

        charts.memory = createLineChart('memory-chart', [
            {
                label: '已用内存',
                data: [],
                borderColor: '#20c997',
                backgroundColor: 'rgba(32, 201, 151, 0.12)',
                tension: 0.3,
                fill: false
            },
            {
                label: '剩余内存',
                data: [],
                borderColor: '#4cc9f0',
                backgroundColor: 'rgba(76, 201, 240, 0.12)',
                tension: 0.3,
                fill: false
            },
            {
                label: '内存使用率',
                data: [],
                borderColor: '#ffb74d',
                backgroundColor: 'rgba(255, 183, 77, 0.12)',
                tension: 0.3,
                fill: false,
                yAxisID: 'y1'
            }
        ], {
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        color: '#9bb0c3',
                        callback: (value) => `${value} GB`
                    },
                    title: {
                        display: true,
                        text: '内存(GB)',
                        color: '#20c997',
                        font: { size: 10, weight: '600' }
                    }
                },
                y1: {
                    position: 'right',
                    beginAtZero: true,
                    max: 100,
                    grid: { drawOnChartArea: false },
                    ticks: {
                        color: '#9bb0c3',
                        callback: (value) => `${value}%`
                    },
                    title: {
                        display: true,
                        text: '使用率(%)',
                        color: '#ffb74d',
                        font: { size: 10, weight: '600' }
                    }
                }
            }
        });

        charts.disk = null;

        charts.network = createLineChart('network-chart', [
            {
                label: '下载',
                data: [],
                borderColor: '#4cc9f0',
                backgroundColor: 'rgba(76, 201, 240, 0.12)',
                tension: 0.3,
                fill: false
            },
            {
                label: '上传',
                data: [],
                borderColor: '#20c997',
                backgroundColor: 'rgba(32, 201, 151, 0.12)',
                tension: 0.3,
                fill: false
            }
        ], {
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: '速率(KB/s)',
                        color: '#4cc9f0',
                        font: { size: 10, weight: '600' }
                    },
                    ticks: {
                        color: '#9bb0c3',
                        callback: (value) => `${value} KB/s`
                    }
                }
            }
        });

            const gpuCanvas = document.getElementById('gpu-chart');
        if (gpuCanvas) {
            const toggles = Array.from(document.querySelectorAll('.gpu-toggle'));
            const datasets = [];
            toggles.forEach((toggle) => {
                const gpuIndex = parseInt(toggle.dataset.gpuIndex, 10);
                const palette = getGpuPalette(gpuIndex);
                datasets.push({
                    label: `GPU${gpuIndex} 负载`,
                    data: [],
                    borderColor: palette.load,
                    backgroundColor: palette.loadBg,
                    tension: 0.3,
                    fill: false,
                    gpuIndex,
                    metric: 'load',
                    yAxisID: 'y',
                    hidden: !toggle.checked
                });
                datasets.push({
                    label: `GPU${gpuIndex} 显存利用率`,
                    data: [],
                    borderColor: palette.mem,
                    backgroundColor: palette.memBg,
                    tension: 0.3,
                    fill: false,
                    gpuIndex,
                    metric: 'mem',
                    yAxisID: 'y',
                    hidden: !toggle.checked
                });
                datasets.push({
                    label: `GPU${gpuIndex} 温度`,
                    data: [],
                    borderColor: palette.temp,
                    backgroundColor: palette.tempBg,
                    tension: 0.3,
                    fill: false,
                    gpuIndex,
                    metric: 'temp',
                    yAxisID: 'y1',
                    hidden: !toggle.checked
                });
            });
            charts.gpu = createLineChart('gpu-chart', datasets, {
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        title: {
                            display: true,
                            text: '使用率(%)',
                            color: '#4cc9f0',
                            font: { size: 10, weight: '600' }
                        },
                        ticks: {
                            color: '#9bb0c3',
                            callback: (value) => `${value}%`
                        }
                    },
                    y1: {
                        position: 'right',
                        min: 0,
                        max: 100,
                        grid: { drawOnChartArea: false },
                        ticks: {
                            color: '#9bb0c3',
                            callback: (value) => `${value}°C`
                        },
                        title: {
                            display: true,
                            text: '温度(°C)',
                            color: '#ffb74d',
                            font: { size: 10, weight: '600' }
                        }
                    }
                }
            });

            const updateGpuVisibility = (selectedIndex) => {
                if (!charts.gpu) return;
                charts.gpu.data.datasets.forEach((dataset) => {
                    dataset.hidden = dataset.gpuIndex !== selectedIndex;
                });
                charts.gpu.update('none');
            };

            const selectedToggle = toggles.find((toggle) => toggle.checked);
            if (selectedToggle) {
                updateGpuVisibility(parseInt(selectedToggle.dataset.gpuIndex, 10));
            }

            toggles.forEach((toggle) => {
                toggle.addEventListener('change', () => {
                    if (!toggle.checked) return;
                    updateGpuVisibility(parseInt(toggle.dataset.gpuIndex, 10));
                });
            });
        }
    }

    async function refreshData() {
        try {
            const response = await fetch('/api/hardware_info');
            const data = await response.json();
            const nowLabel = new Date().toLocaleTimeString('zh-CN', { hour12: false });

            if (data.cpu) {
                const totalUsage = data.cpu.total_usage ?? 0;
                const avgTemp = calcAvgCoreTemp(data.temperatures);

                let maxUsage = null;
                let minUsage = null;
                let maxIndex = null;
                let minIndex = null;

                if (Array.isArray(data.cpu.usage_per_core) && data.cpu.usage_per_core.length) {
                    data.cpu.usage_per_core.forEach((usage, index) => {
                        if (typeof usage !== 'number') return;
                        if (maxUsage === null || usage > maxUsage) {
                            maxUsage = usage;
                            maxIndex = index;
                        }
                        if (minUsage === null || usage < minUsage) {
                            minUsage = usage;
                            minIndex = index;
                        }
                    });
                }

                pushChartPoint(
                    charts.cpu,
                    nowLabel,
                    [
                        totalUsage,
                        avgTemp !== null ? avgTemp : 0,
                        maxUsage !== null ? maxUsage : 0,
                        minUsage !== null ? minUsage : 0
                    ],
                    [null, null, maxIndex, minIndex]
                );

                if (Array.isArray(data.cpu.usage_per_core)) {
                    data.cpu.usage_per_core.forEach((usage, index) => {
                        const coreItem = document.querySelector(`.core-item[data-core-index="${index}"]`);
                        if (!coreItem) return;
                        const usageEl = coreItem.querySelector('.core-usage');
                        if (usageEl) usageEl.textContent = `${usage.toFixed(1)}%`;
                        coreItem.classList.remove('core-high', 'core-medium', 'core-low');
                        if (usage >= 80) coreItem.classList.add('core-high');
                        else if (usage >= 50) coreItem.classList.add('core-medium');
                        else coreItem.classList.add('core-low');
                    });
                }

                const coreTemps = getSortedCoreTemps(data.temperatures);
                if (coreTemps.length) {
                    coreTemps.forEach((temp, index) => {
                        const coreItem = document.querySelector(`.core-item[data-core-index="${index}"] .core-temp`);
                        if (coreItem && typeof temp === 'number') {
                            coreItem.textContent = `${temp.toFixed(1)}°C`;
                        }
                    });
                }
            }

            if (data.memory) {
                const memPercent = data.memory.percent ?? 0;
                const memProgress = document.getElementById('memory-progress');
                if (memProgress) memProgress.style.width = `${memPercent}%`;

                const totalBytes = data.memory.total ?? 0;
                const usedBytes = data.memory.used ?? 0;
                const freeBytes = data.memory.free ?? Math.max(0, totalBytes - usedBytes);

                const usedGb = totalBytes ? usedBytes / 1073741824 : 0;
                const freeGb = totalBytes ? freeBytes / 1073741824 : 0;

                if (data.memory.type) {
                    const el = document.getElementById('memory-type');
                    if (el) el.textContent = data.memory.type;
                }
                if (data.memory.frequency) {
                    const el = document.getElementById('memory-frequency');
                    if (el) el.textContent = `${data.memory.frequency} MHz`;
                }
                if (data.memory.channels) {
                    const el = document.getElementById('memory-channels');
                    if (el) el.textContent = data.memory.channels;
                }
                const totalEl = document.getElementById('memory-total');
                if (totalEl && totalBytes) {
                    totalEl.textContent = `${(totalBytes / 1073741824).toFixed(1)} GB`;
                }

                pushChartPoint(charts.memory, nowLabel, [usedGb, freeGb, memPercent]);
            }

            if (data.disk && Array.isArray(data.disk)) {
                const minBytes = 50 * 1024 * 1024 * 1024;
                const skipFs = new Set(['squashfs', 'tmpfs', 'devtmpfs', 'overlay', 'proc', 'sysfs', 'cgroup', 'pstore', 'autofs', 'debugfs', 'tracefs', 'securityfs', 'mqueue']);
                let total = 0;
                let used = 0;
                data.disk.forEach(disk => {
                    const fsType = (disk.filesystem || disk.fstype || '').toLowerCase();
                    if (skipFs.has(fsType)) return;
                    if (disk.total !== undefined && disk.used !== undefined) {
                        const t = typeof disk.total === 'number' ? disk.total : parseFloat(disk.total);
                        const u = typeof disk.used === 'number' ? disk.used : parseFloat(disk.used);
                        if (!Number.isNaN(t) && !Number.isNaN(u) && t >= minBytes) {
                            total += t;
                            used += u;
                        }
                    }
                });
                const percent = total > 0 ? (used / total) * 100 : 0;
                const diskPercentEl = document.getElementById('disk-percent');
                if (diskPercentEl) {
                    diskPercentEl.textContent = `${percent.toFixed(1)}%`;
                }
            }

            if (data.network) {
                let rxSpeed = data.network.rx_speed;
                let txSpeed = data.network.tx_speed;
                if (typeof rxSpeed !== 'number' || typeof txSpeed !== 'number') {
                    const now = Date.now();
                    if (lastNet) {
                        const timeDiff = (now - lastNetTime) / 1000;
                        if (timeDiff > 0) {
                            rxSpeed = (data.network.rx_bytes - lastNet.rx_bytes) / timeDiff;
                            txSpeed = (data.network.tx_bytes - lastNet.tx_bytes) / timeDiff;
                        }
                    }
                    lastNet = { rx_bytes: data.network.rx_bytes, tx_bytes: data.network.tx_bytes };
                    lastNetTime = now;
                }

                const downEl = document.getElementById('network-down');
                const upEl = document.getElementById('network-up');
                if (downEl && typeof rxSpeed === 'number') downEl.textContent = formatSpeed(rxSpeed);
                if (upEl && typeof txSpeed === 'number') upEl.textContent = formatSpeed(txSpeed);

                const downKb = typeof rxSpeed === 'number' ? rxSpeed / 1024 : 0;
                const upKb = typeof txSpeed === 'number' ? txSpeed / 1024 : 0;
                pushChartPoint(charts.network, nowLabel, [downKb, upKb]);
            }

            if (data.gpu && Array.isArray(data.gpu) && charts.gpu) {
                const values = charts.gpu.data.datasets.map((dataset) => {
                    const gpuIndex = dataset.gpuIndex;
                    const gpu = data.gpu[gpuIndex];
                    if (!gpu) return 0;
                    if (dataset.metric === 'load') {
                        return typeof gpu.load === 'number' ? gpu.load : 0;
                    }
                    if (dataset.metric === 'mem') {
                        return gpu.memory && typeof gpu.memory.percent === 'number' ? gpu.memory.percent : 0;
                    }
                    if (dataset.metric === 'temp') {
                        return typeof gpu.temperature === 'number' ? gpu.temperature : 0;
                    }
                    return 0;
                });

                if (charts.gpu.data.labels.length >= HISTORY_LIMIT) {
                    charts.gpu.data.labels.shift();
                    charts.gpu.data.datasets.forEach((dataset) => dataset.data.shift());
                }
                charts.gpu.data.labels.push(nowLabel);
                charts.gpu.data.datasets.forEach((dataset, index) => {
                    dataset.data.push(values[index]);
                });
                charts.gpu.update('none');
            }
        } catch (error) {
            console.error('获取硬件数据失败:', error);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        updateTime();
        setInterval(updateTime, 1000);
        initCharts();
        refreshData();
        setInterval(refreshData, 5000);
    });
</script>
</body>
</html>
